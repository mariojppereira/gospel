"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[311],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return u}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=l(n),u=i,f=m["".concat(c,".").concat(u)]||m[u]||d[u]||o;return n?a.createElement(f,r(r({ref:t},p),{},{components:n})):a.createElement(f,r({ref:t},p))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var l=2;l<o;l++)r[l]=n[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},285:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return p},default:function(){return m}});var a=n(7462),i=n(3366),o=(n(7294),n(3905)),r=["components"],s={sidebar_position:2},c="Your first specification",l={unversionedId:"getting-started/first-spec",id:"getting-started/first-spec",isDocsHomePage:!1,title:"Your first specification",description:"Let us get started with a simple specification example, and specify a generic",source:"@site/docs/getting-started/first-spec.md",sourceDirName:"getting-started",slug:"/getting-started/first-spec",permalink:"/gospel/getting-started/first-spec",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Installing Gospel",permalink:"/gospel/getting-started/installation"},next:{title:"Now what?",permalink:"/gospel/getting-started/tools"}},p=[{value:"Models and invariants for <code>&#39;a t</code>",id:"models-and-invariants-for-a-t",children:[],level:2},{value:"Your first function contract: <code>create</code>",id:"your-first-function-contract-create",children:[],level:2},{value:"Simple accessors: <code>is_empty</code> and <code>mem</code>",id:"simple-accessors-is_empty-and-mem",children:[],level:2},{value:"Mutating arguments and raising exceptions",id:"mutating-arguments-and-raising-exceptions",children:[],level:2},{value:"Type-checking your specification",id:"type-checking-your-specification",children:[],level:2}],d={toc:p};function m(e){var t=e.components,n=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"your-first-specification"},"Your first specification"),(0,o.kt)("p",null,"Let us get started with a simple specification example, and specify a generic\ninterface for polymorphic, limited capacity containers."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ocaml"},"type 'a t\n(** The type for containers. *)\n\nexception Full\n\nval create: int -> 'a t\n(** [create capacity] is an empty container which maximum capacity\n    is [capacity]. *)\n\nval is_empty: 'a t -> bool\n(** [is_empty t] is [true] iff [t] contains no elements. *)\n\nval clear: 'a t -> unit\n(** [clear t] removes all values in [t]. *)\n\nval add: 'a t -> 'a -> unit\n(** [add t x] adds [x] to the container [t], or raises [Full] if\n    [t] has reached its maximum capacity. *)\n\nval mem: 'a t -> 'a -> bool\n(** [mem t x] is [true] iff [t] contains [x]. *)\n")),(0,o.kt)("p",null,"Gospel specifications live in special comments, starting with the ",(0,o.kt)("inlineCode",{parentName:"p"},"@")," character.\nThese comments may be attached to type declarations or value declarations. They\nprovide a specification for the signature item they are attached to."),(0,o.kt)("h2",{id:"models-and-invariants-for-a-t"},"Models and invariants for ",(0,o.kt)("inlineCode",{parentName:"h2"},"'a t")),(0,o.kt)("p",null,"Let's start by specifying the abstract type ",(0,o.kt)("inlineCode",{parentName:"p"},"'a t"),". As a container with fixed\ncapacity, we can model it with two bits of information: a fixed integer\ncapacity, and a set of ",(0,o.kt)("inlineCode",{parentName:"p"},"'a")," values, representing its contents. Note that the\ncapacity is not mutable, while the contents are. This logical modelisation of\nthe container directly translates into Gospel:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ocaml"},"type 'a t\n(** The type for containers. *)\n(*@ model capacity: int\n    mutable model contents: 'a set *)\n")),(0,o.kt)("p",null,"Notice that documentation comments and Gospel specifications can coexist and\neven often help understand each other! However, for the sake of brevity, we will\nomit docstrings in the rest of this section."),(0,o.kt)("p",null,"One may also note that the capacity must be positive, and the number of values\nin the ",(0,o.kt)("inlineCode",{parentName:"p"},"contents")," set may not exceed ",(0,o.kt)("inlineCode",{parentName:"p"},"capacity"),". Those are type invariants:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ocaml"},"type 'a t\n(*@ model capacity: int\n    mutable model contents: 'a set\n    invariant capacity > 0\n    invariant Set.cardinal contents <= capacity *)\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Set")," module is part of the ",(0,o.kt)("a",{parentName:"p",href:"../stdlib"},"Gospel standard library"),". Although it\ntries to mimic familiar interfaces from the OCaml standard library, those two\nshould not be confused: logical declarations only can appear in specifications."),(0,o.kt)("p",null,"Now that we annotated our type with its models and invariants, we can attach\nspecifications to the functions to show how they interact with the container."),(0,o.kt)("h2",{id:"your-first-function-contract-create"},"Your first function contract: ",(0,o.kt)("inlineCode",{parentName:"h2"},"create")),(0,o.kt)("p",null,"The function ",(0,o.kt)("inlineCode",{parentName:"p"},"create")," returns a container when provided a capacity. We may want\nto specify three bits of information:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The provided capacity is positive."),(0,o.kt)("li",{parentName:"ul"},"The capacity of the returned container is indeed the one received as an\nargument."),(0,o.kt)("li",{parentName:"ul"},"The container is empty.")),(0,o.kt)("p",null,"Let's write a Gospel formalisation of that contract. The contract starts with a\nheader that lets us name the arguments and return value (we will call the\nargument ",(0,o.kt)("inlineCode",{parentName:"p"},"c")," and the return value ",(0,o.kt)("inlineCode",{parentName:"p"},"t"),") to mention them in the rest of the\nspecification. The first property is a pre-condition of the function (we use the\nkeyword ",(0,o.kt)("inlineCode",{parentName:"p"},"requires"),"), while the second and third ones are post-conditions (the\nkeyword is ",(0,o.kt)("inlineCode",{parentName:"p"},"ensures"),"):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ocaml"},"val create: int -> t\n(*@ t = create c\n    requires c > 0\n    ensures t.capacity = c\n    ensures t.contents = Set.empty *)\n")),(0,o.kt)("h2",{id:"simple-accessors-is_empty-and-mem"},"Simple accessors: ",(0,o.kt)("inlineCode",{parentName:"h2"},"is_empty")," and ",(0,o.kt)("inlineCode",{parentName:"h2"},"mem")),(0,o.kt)("p",null,"Now on to ",(0,o.kt)("inlineCode",{parentName:"p"},"is_empty")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"mem"),"."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"is_empty t")," is true if and only if ",(0,o.kt)("inlineCode",{parentName:"p"},"t")," is empty; this is a post-condition. This\nfunction also (hopefully) has no side-effect: it does not modify ",(0,o.kt)("inlineCode",{parentName:"p"},"t"),", does not\ndepend on any internal state, and does not raise exceptions. In Gospel's\nlanguage, this function is ",(0,o.kt)("em",{parentName:"p"},"pure"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ocaml"},"val is_empty: t -> bool\n(*@ b = is_empty t\n    pure\n    ensures b <-> t.capacity = Set.empty *)\n")),(0,o.kt)("p",null,"The specification for ",(0,o.kt)("inlineCode",{parentName:"p"},"mem")," is similar:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ocaml"},"val mem: 'a t -> 'a -> bool\n(*@ b = mem t x\n    pure\n    ensures b <-> Set.mem x t.contents *)\n")),(0,o.kt)("h2",{id:"mutating-arguments-and-raising-exceptions"},"Mutating arguments and raising exceptions"),(0,o.kt)("p",null,"Finally, let us specify ",(0,o.kt)("inlineCode",{parentName:"p"},"clear")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"add"),", which are functions that mutate the\ncontainer."),(0,o.kt)("p",null,"Function ",(0,o.kt)("inlineCode",{parentName:"p"},"clear")," removes any element in its argument: it is empty after the\ncall. Obviously, it modifies the ",(0,o.kt)("inlineCode",{parentName:"p"},"contents")," model of its argument. After its\nexecution, the container should be empty. Note that we are only allowed to\nmention ",(0,o.kt)("inlineCode",{parentName:"p"},"is_empty")," in the specification because it is a pure function;\nattempting to use a non-pure OCaml function in a specification will result in a\nGospel error."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ocaml"},"val clear: 'a t -> unit\n(*@ clear t\n    modifies t.contents\n    ensures is_empty t *)\n")),(0,o.kt)("p",null,"A first attempt at specifying ",(0,o.kt)("inlineCode",{parentName:"p"},"add")," is similar to the previous examples. We use\nGospel's ",(0,o.kt)("inlineCode",{parentName:"p"},"old")," primitive to refer to the state of the container prior to the\nfunction execution:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ocaml"},"val add: 'a t -> 'a -> unit\n(*@ add t x\n    modifies t.contents\n    ensures t.contents = Set.add x (old t.contents) *)\n")),(0,o.kt)("p",null,"Notice, however, that this specification is incomplete. Indeed, one specificity\nof this function is that it can raise ",(0,o.kt)("inlineCode",{parentName:"p"},"Full"),". Let us complete that contract with\nthis bit of information. If ",(0,o.kt)("inlineCode",{parentName:"p"},"add")," raises ",(0,o.kt)("inlineCode",{parentName:"p"},"Full"),", we can deduce that ",(0,o.kt)("inlineCode",{parentName:"p"},"t.contents"),"\nalready contains ",(0,o.kt)("inlineCode",{parentName:"p"},"t.capacity")," elements."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ocaml"},"val add: 'a t -> 'a -> unit\n(*@ add t x\n    modifies t.contents\n    ensures t.contents = Set.add x (old t.contents)\n    raises Full -> Set.cardinal (old t.contents) = t.capacity\n                /\\ t.contents = old t.contents *)\n")),(0,o.kt)("p",null,"Since we have a ",(0,o.kt)("inlineCode",{parentName:"p"},"modifies")," clause, the contents of ",(0,o.kt)("inlineCode",{parentName:"p"},"t")," may be mutated even when\n",(0,o.kt)("inlineCode",{parentName:"p"},"Full")," is raised. The last line of specification forbids such a behavior."),(0,o.kt)("p",null,"Notice how we did not need to repeat that ",(0,o.kt)("inlineCode",{parentName:"p"},"S.cardinal t.contents <= t.capacity"),"\nin every contract; as a type invariant, this property implicitely holds in every\nfunction's pre-state and post-state."),(0,o.kt)("h2",{id:"type-checking-your-specification"},"Type-checking your specification"),(0,o.kt)("p",null,"We're done! Our module interface is fully specified, independently of any\nimplementation. Let's finish by verifying that these are well-typed, and call\nGospel's type-checker:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"$ gospel check ./container.mli\nOK\n")))}m.isMDXComponent=!0}}]);